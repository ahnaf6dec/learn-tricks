<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Introduction to Recursion - Complete Notes</title>

<style>
    body {
        font-family: "Segoe UI", Arial, sans-serif;
        background-color: #f4f6fb;
        color: #1f2937;
        line-height: 1.7;
        margin: 0;
        padding: 24px;
    }

    h1 {
        text-align: center;
        color: #1d4ed8;
        border-bottom: 3px solid #1d4ed8;
        padding-bottom: 10px;
    }

    h2 {
        color: #1e40af;
        margin-top: 32px;
    }

    h3 {
        color: #1f3a8a;
        margin-top: 20px;
    }

    .section {
        background: #ffffff;
        padding: 22px;
        margin: 22px 0;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    }

    pre, code {
        background: #0f172a;
        color: #e5e7eb;
        padding: 14px;
        border-radius: 6px;
        overflow-x: auto;
        display: block;
    }

    .note {
        background: #e0ecff;
        border-left: 5px solid #2563eb;
        padding: 12px;
        margin: 16px 0;
    }

    .warning {
        background: #fff3cd;
        border-left: 5px solid #f59e0b;
        padding: 12px;
        margin: 16px 0;
    }

    .danger {
        background: #fee2e2;
        border-left: 5px solid #dc2626;
        padding: 12px;
        margin: 16px 0;
    }

    ul {
        margin-left: 20px;
    }

    footer {
        text-align: center;
        margin-top: 40px;
        color: #475569;
        font-size: 14px;
    }
</style>
</head>

<body>

<h1>Introduction to Recursion</h1>

<div class="section">
<h2>1. What is Recursion?</h2>

<p>
Recursion is a programming technique in which a function calls itself in order to solve a problem.
</p>

<div class="note">
A recursive solution breaks a problem into smaller subproblems of the same type.
</div>

<p>
Every recursive function must contain:
</p>

<ul>
    <li>A recursive call (function calling itself)</li>
    <li>A base condition (to stop recursion)</li>
</ul>
</div>

<div class="section">
<h2>2. Simple Example of Recursion</h2>

<pre>
void printOne() {
    cout << 1 << endl;
    printOne();
}
</pre>

<div class="danger">
This function has no stopping condition. It will call itself infinitely.
</div>
</div>

<div class="section">
<h2>3. Infinite Recursion</h2>

<p>
If a recursive function does not contain a base condition, it leads to infinite recursion.
</p>

<p>
In infinite recursion:
</p>

<ul>
    <li>The function keeps calling itself</li>
    <li>Previously called functions remain incomplete</li>
    <li>Memory usage keeps increasing</li>
</ul>
</div>

<div class="section">
<h2>4. Stack Space and Function Calls</h2>

<p>
Whenever a function is called, it is stored in a memory area called the call stack.
</p>

<ul>
    <li>Each function call occupies stack memory</li>
    <li>A function is removed from the stack only after it finishes execution</li>
</ul>

<p>
If functions keep getting added without finishing, stack memory overflows.
</p>

<div class="danger">
This situation is known as stack overflow.
</div>
</div>

<div class="section">
<h2>5. Base Condition</h2>

<p>
The base condition is the condition under which the recursive function stops calling itself.
</p>

<div class="note">
Without a base condition, recursion is unsafe and incorrect.
</div>

<h3>Example: Print numbers from 0 to 2</h3>

<pre>
int cnt = 0;

void printNumbers() {
    if (cnt == 3) return;   // base condition

    cout << cnt << endl;
    cnt++;
    printNumbers();
}

int main() {
    printNumbers();
}
</pre>

<h3>Output</h3>

<pre>
0
1
2
</pre>
</div>

<div class="section">
<h2>6. How Recursion Executes (Dry Run)</h2>

<p>
Initial value: cnt = 0
</p>

<ul>
    <li>printNumbers() → prints 0 → cnt becomes 1</li>
    <li>printNumbers() → prints 1 → cnt becomes 2</li>
    <li>printNumbers() → prints 2 → cnt becomes 3</li>
    <li>Base condition satisfied → function returns</li>
</ul>

<p>
After the base condition, all pending function calls return one by one.
</p>
</div>

<div class="section">
<h2>7. Recursion Tree</h2>

<p>
A recursion tree is a diagrammatic way to represent recursive function calls.
</p>

<h3>Example Representation</h3>

<pre>
printNumbers(0)
    |
printNumbers(1)
    |
printNumbers(2)
    |
printNumbers(3)  -> base condition
</pre>

<p>
The recursion tree helps visualize:
</p>

<ul>
    <li>Order of function calls</li>
    <li>Depth of recursion</li>
    <li>Execution flow</li>
</ul>
</div>

<div class="section">
<h2>8. Why Recursion Terminates Safely</h2>

<ul>
    <li>Base condition stops further recursive calls</li>
    <li>Functions return in reverse order</li>
    <li>Stack memory is freed correctly</li>
</ul>
</div>

<div class="section">
<h2>9. Common Mistakes</h2>

<ul>
    <li>Missing base condition</li>
    <li>Incorrect base condition</li>
    <li>Recursive call before base condition</li>
    <li>Very deep recursion causing stack overflow</li>
</ul>
</div>

<div class="section">
<h2>10. Key Points to Remember</h2>

<ul>
    <li>Recursion is based on self-calling functions</li>
    <li>Base condition is mandatory</li>
    <li>Each recursive call uses stack space</li>
    <li>Infinite recursion leads to stack overflow</li>
    <li>Recursion trees help in understanding execution</li>
</ul>
</div>

<footer>
<p>General Purpose Recursion Notes</p>
<p>Suitable for exams, interviews, and competitive programming</p>
</footer>

<script>
console.log("Recursion notes loaded");
</script>

</body>
</html>
